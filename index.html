<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>答案之书 — 随机一句</title>
  <meta name="color-scheme" content="light dark">
  <style>
    :root{
      --bg1: #061026;
      --bg2: #04121e;
      --accent: #7dd3fc;
      --accent-2:#a78bfa;
      --text: #e6eef8;
      --muted: #9fb4c8;
    }

    html,body{
      height:100%;
      margin:0;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--text);
      font-family:Inter, "PingFang SC", "Microsoft Yahei", system-ui, -apple-system, "Helvetica Neue", Arial, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* starfield canvas (flowing stars) */
    .starfield {
      position:fixed;
      inset:0;
      z-index:-4;
      pointer-events:none;
      background: radial-gradient(ellipse at 50% 10%, rgba(255,255,255,0.02), transparent 20%), transparent;
    }

    /* subtle blobs for depth */
    .blob { position:fixed; z-index:-3; filter: blur(60px) saturate(120%); opacity:0.08; pointer-events:none; }
    .blob.one{ width:520px;height:520px; left:-8%; top:6%; background: radial-gradient(circle at 30% 30%, var(--accent) 0%, transparent 40%); animation: blobMove1 12s ease-in-out infinite alternate; }
    .blob.two{ width:420px;height:420px; right:-8%; bottom:-6%; background: radial-gradient(circle at 60% 60%, var(--accent-2) 0%, transparent 45%); animation: blobMove2 14s ease-in-out infinite alternate; }
    @keyframes blobMove1{ from{transform:translateY(0) scale(1)} to{transform:translateY(14px) scale(1.05)} }
    @keyframes blobMove2{ from{transform:translateY(0) scale(1)} to{transform:translateY(-16px) scale(1.08)} }

    /* layout & card */
    .wrap{ min-height:100%; display:flex; align-items:center; justify-content:center; padding:24px; box-sizing:border-box; position:relative; z-index:0; }
    .card{
      width: min(92vw, 920px);
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: clamp(28px, 6vw, 48px);
      box-shadow: 0 8px 30px rgba(4,6,12,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
      display:flex; flex-direction:column; align-items:center; gap:18px;
      backdrop-filter: blur(6px) saturate(120%);
    }

    .answer {
      text-align:center;
      font-weight:700;
      color:var(--text);
      font-size: clamp(20px, 5.5vw, 52px);
      line-height:1.12;
      max-width:1100px;
      padding: 8px 12px;
      border-radius:10px;
      transition: transform .32s cubic-bezier(.2,.8,.2,1), opacity .28s ease;
      will-change: transform, opacity;
      text-shadow: 0 6px 24px rgba(2,6,23,0.45);
      position:relative;
    }
    .answer::after{
      content:"";
      position:absolute; left:50%; transform:translateX(-50%); bottom:-12px; height:4px; width:40%; border-radius:4px;
      background: linear-gradient(90deg, rgba(125,211,252,0.9), rgba(167,139,250,0.9));
      opacity:0.95;
      filter: blur(6px);
    }
    .answer.hidden { opacity:0; transform: translateY(8px) scale(.995); }
    .answer.pop { transform: scale(1.02); transition: transform .35s cubic-bezier(.175,.885,.32,1); }

    .controls { display:flex; gap:10px; align-items:center; margin-top:6px; flex-wrap:wrap; }
    .btn {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.06);
      color:var(--text);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:600;
      box-shadow: 0 3px 12px rgba(3,8,20,0.4);
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    }
    .btn.secondary{ background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--muted); }
    .btn:active{ transform:translateY(1px) scale(.998); }
    .small { font-size:13px; color:var(--muted); }

    .hint { color:var(--muted); font-size:13px; text-align:center; margin-top:6px; }

    @media (max-width:520px){
      .answer::after{ width:60%; bottom:-10px; }
      .card{ padding:20px; border-radius:12px; }
    }

    /* respect reduced motion */
    @media (prefers-reduced-motion: reduce){
      .starfield { display:none; }
      .blob { animation:none; }
      .answer, .btn { transition:none; }
    }
  </style>
</head>
<body>
  <!-- starfield canvas for flowing stars -->
  <canvas class="starfield" id="starfield" aria-hidden="true"></canvas>

  <div class="blob one" aria-hidden="true"></div>
  <div class="blob two" aria-hidden="true"></div>

  <main class="wrap" role="main">
    <section class="card" aria-labelledby="title">
      <h1 id="title" style="margin:0; font-size:16px; font-weight:700; color:var(--muted); letter-spacing:0.08em;">答案之书</h1>

      <div id="answer" class="answer" role="status" aria-live="polite">载入中…</div>

      <div class="controls" role="toolbar" aria-label="controls">
        <button id="newBtn" class="btn" title="换一个 (空格)">换一个</button>
        <button id="copyBtn" class="btn secondary" title="复制当前答案">复制</button>
      </div>

      <div class="hint">按 空格 换一句 · 支持复制 · 可用 answers.json 覆盖内置列表</div>
    </section>
  </main>

  <script>
    (function(){
      // --------------------------
      // Starfield (flowing stars)
      // --------------------------
      const canvas = document.getElementById('starfield');
      const ctx = canvas.getContext('2d', { alpha: true });
      let stars = [];
      let width = 0, height = 0, dpr = Math.max(1, window.devicePixelRatio || 1);
      const REDUCED = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      function resize() {
        dpr = Math.max(1, window.devicePixelRatio || 1);
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        initStars();
      }

      // Initialize star objects with depth (parallax) and speed
      function initStars() {
        stars = [];
        // density tuned for pleasant look on different sizes
        const area = width * height;
        const baseCount = Math.round(area * 0.00028); // e.g., ~280 on 1000x1000
        const count = Math.max(80, Math.min(1000, baseCount));
        for (let i = 0; i < count; i++) {
          // depth 0..1: closer stars are brighter and faster
          const z = Math.random(); // 0 (far) - 1 (near)
          const size = (0.4 + z * 1.6) * (Math.random() * 0.9 + 0.6); // px
          const speed = 8 + z * 40 + Math.random() * 20; // px/sec baseline
          const x = Math.random() * width;
          const y = Math.random() * height;
          const twinkleSpeed = 0.5 + Math.random() * 1.5; // twinkle frequency
          const hueOffset = (Math.random() * 40) - 20; // slight color variation
          stars.push({ x, y, size, speed, z, twinkleSpeed, hueOffset, phase: Math.random() * Math.PI * 2 });
        }
      }

      let last = performance.now();
      let rafId = null;

      function draw(now) {
        const dt = Math.min(60, now - last) / 1000; // seconds
        last = now;

        // subtle background fade for motion trails (not too strong)
        ctx.clearRect(0, 0, width, height);

        // draw gradient faint nebula (subtle)
        const g = ctx.createLinearGradient(0, 0, width, height * 0.6);
        g.addColorStop(0, 'rgba(6,16,38,0.08)');
        g.addColorStop(1, 'rgba(4,8,16,0.02)');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, width, height);

        // update and draw stars
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          // move stars diagonally down-left to create flowing effect (slightly leftwards)
          const vx = -(10 + s.z * 40) * dt; // horizontal movement (left)
          const vy = (10 + s.z * 60) * dt;  // vertical movement (down)
          s.x += vx;
          s.y += vy;

          // wrap around edges
          if (s.y > height + 10 || s.x < -20) {
            // respawn at top-right quadrant
            s.x = width + Math.random() * 60;
            s.y = -Math.random() * 80;
          }

          // twinkle: brightness varies with sin wave + small random
          s.phase += s.twinkleSpeed * dt;
          const tw = 0.4 + 0.6 * Math.abs(Math.sin(s.phase));

          // color and alpha
          const alpha = 0.5 + 0.5 * tw * (0.6 + s.z * 0.8);
          const glow = Math.min(1, 0.5 + s.z * 0.9 + tw * 0.4);

          // draw glow
          const grad = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, s.size * 6);
          const color = `rgba(${230 + s.hueOffset}, ${240 + s.hueOffset/2}, 255, ${0.12 * glow})`;
          grad.addColorStop(0, color);
          grad.addColorStop(0.15, `rgba(255,255,255,${0.14 * glow})`);
          grad.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size * 6, 0, Math.PI * 2);
          ctx.fill();

          // draw core
          ctx.fillStyle = `rgba(255,255,255,${alpha})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
          ctx.fill();
        }

        rafId = requestAnimationFrame(draw);
      }

      // start/stop star animation depending on reduced motion
      function startStarfield() {
        if (REDUCED) return;
        if (rafId == null) {
          last = performance.now();
          rafId = requestAnimationFrame(draw);
        }
      }
      function stopStarfield() {
        if (rafId != null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
      }

      // initialize
      resize();
      startStarfield();

      // handle resize (debounced)
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(resize, 180);
      });

      // pause when hidden to save CPU
      document.addEventListener('visibilitychange', () => {
        if (document.hidden) stopStarfield();
        else startStarfield();
      });

      // --------------------------
      // Answer display + controls
      // --------------------------
      const answerEl = document.getElementById('answer');
      const newBtn = document.getElementById('newBtn');
      const copyBtn = document.getElementById('copyBtn');

      const builtin = [
        "别太赶了","别想了","不然呢？","要求不要太高","这是必然的，不要抗拒","不要做得过火了",
        "大胆一点","大方一点","毫无疑问","好运将会降临","肯定的","没错","还有别的选择",
        "你将取得成功","需要冒险","要主动","你在开玩笑吗？","你做什么都没用","千万不能失败",
        "想得美","休息一下就好了","眼光长远一点","要变通","一笑了之","以后再说","用尽一切办法去努力",
        "有","有可能","仔细想想再说","障碍重重","这不可取","值得奋斗","重新想想","注意细节",
        "结果会让你惊喜","不作死就不会死","当局者迷","时间会证明一切","不要抱期望","换个角度想想",
        "会很顺利","继续前进","你必须解决一些相关的问题","不会失望的","奇迹即将降临","尚待时日",
        "省点力气吧","听听专家的意见","为什么不呢？","现在还说不清","现在你可以","学会妥协","要有点耐心",
        "要知足","一定会有好结果的","改变心情","一直走下去","不适合","愉快生活","终点","换一个方向",
        "岁月静好","放轻松这很简单","早点儿开始","不要后悔","沉默","好像平凡了点","糊涂一点更好",
        "善待自己","呼吸一下新鲜空气","感恩，运气会越来越好","原谅","自我欣赏","复杂的事情简单做",
        "学会自己保护自己","奇迹","给自己一个肯定","摆正心态","种下满足，收获幸福","学会好奇",
        "最美丽的一天","永恒","不要刻意隐藏","不要刻意压抑","驻足静立","采用一个冒险的态度",
        "允许你先休息一下","避免第一个解决方案","寻求援助会让你成功","需要耐心","实际一点吧",
        "木已成舟","这可能很难，家是永远的避风港","学会改变什么","不要去忘记","最划算的交易",
        "自信起来吧","学会成长","接受那些消失的","最好的事情正要发生","到此为止","没有什么是对的",
        "时间有限","必须努力奔跑起来","慢下来","会有人陪着你","挥手道别","站起来去战斗",
        "事情会朝目标发展","不要看轻别人","未来可期","多读一本书","平平安安","出发","挥别错的",
        "差不多得了","有一些重要的事必须去做","用平淡的心态去追求","有人浪费了你的时间","一切皆有可能",
        "事情没有看起来那么糟","不要回头","勇敢去做","你需要更多的爱","这会是一个惊喜","保持微笑",
        "相信直觉","放下过去","拥抱变化","享受过程","别犹豫","专注当下","耐心等待","果断行动",
        "别纠结","顺其自然","这是正确的选择","别放弃","再试一次","你是对的","保持冷静",
        "别太较真","简单点","慢慢来","别担心","你能做到","这很值得","别勉强","听从内心",
        "珍惜拥有","学会放下","向前看","别着急","保持希望","这只是开始","会好起来的",
        "别太在意","换种方式","你很棒","坚持住","别偷懒","用心去做","别害怕","大胆尝试",
        "这是暂时的","别自责","保持初心","别冲动","理性看待","灵活应对","乐观一点","积极面对",
        "别拖延","主动出击","这需要时间","保持专注","别抱怨","学会感恩","这是必然的","别计较",
        "学会宽容","这很正常","调整节奏","给自己空间","别盲从","独立思考","这很简单",
        "别高估自己","别低估自己","保持热情","别冷漠","学会沟通","这会有回报","耐心点",
        "别浮躁","脚踏实地","仰望星空","活在当下","别后悔","这是成长","接受现实","期待未来",
        "别迷茫","找到方向","这是机遇","别错过","抓住机会","这是挑战","勇敢面对","别逃避",
        "直面问题","这会过去的","别难过","开心点","这很有趣","保持好奇","别麻木","热爱生活",
        "这是缘分","别强求","顺其自然","这是命运","别抗拒","坦然面对",
        "建议先吃顿好的，吃饱了才有力气纠结","答案在奶茶里，喝到第三杯就会显现",
        "这件事得看运气——主要看你今天有没有捡到钱","别想了，你家猫已经替你做了决定",
        "结果不重要，重要的是你纠结的样子很可爱","不如去打游戏，赢一把就当答案是肯定的",
        "老天爷说：这事我也管不了，你自己看着办","答案是“下次一定”，但这次先躺平",
        "为什么数学书最忧伤？因为它有太多问题——跟你一样","你钱包的厚度，决定了这件事的难度",
        "建议抛硬币，正面去做，反面再抛一次","其实答案是“多喝热水”，但我怕你打我",
        "企鹅的肚子是白色的——因为它不想让你看清它的纠结","这件事就像减肥，说起来容易做起来难",
        "蜗牛都比你果断，它至少知道要慢慢爬","别问答案，问就是“干饭要紧”",
        "你的好运正在配送中，预计迟到365天","如果这件事太难，可能是老天在考验你的奶茶预算",
        "答案藏在你的表情包里，翻到第8个就懂了","不如睡一觉，梦里会有更靠谱的答案",
        "你纠结的样子，像极了想减肥又想吃宵夜的我","这件事的成功率，跟你早起的概率成正比",
        "建议去逛超市，货架会告诉你该选哪样","老天爷打了个哈欠：这事我忘了安排",
        "答案是“可以，但没必要”——主打一个随性","你家WiFi信号都比你果断，说断就断",
        "别纠结了，隔壁小孩都知道该选奶茶","这件事就像穿袜子，左脚对了右脚可能错",
        "如果感到迷茫，就去洗个澡——水会告诉你答案（其实是让你冷静）",
        "你的宠物已经看穿一切，但它懒得告诉你","成功概率≈你不熬夜的天数，自己算",
        "建议听首歌，歌词里藏着答案——前提是你能听懂","这件事得等月亮圆了，主要是图个仪式感",
        "答案是“yes or no”，具体是哪个？看你今天的心情","别想了，再想头发就要离家出走了",
        "你纠结的时间，足够刷完一集剧，不如先追剧","老天爷偷偷告诉我：这事有点悬，但你可爱就行",
        "建议问你的输入法，打出来的第一个词就是答案","这件事就像拆盲盒，不管怎样都有惊喜（或惊吓）",
        "没钱解决不了的问题，有钱没解决不了的——包括这件事",
        "其实你内心早就有答案，只是想找个人夸你做得对",
        "这事真不行，别硬撑了","听我的，赶紧放弃这个念头","此路不通，换条道走",
        "不建议你这么做，容易踩坑","算了吧，大概率会后悔","方向错了，再努力也白费",
        "达咩！这个选择真的不太行","别折腾了，结局大概率不理想","强烈不推荐，懂的都懂",
        "行不通的，趁早收手","省省力气吧，这事成不了","劝你三思，真的没必要",
        "这个想法pass，换个靠谱的","别往火坑里跳，快撤","大概率会翻车，慎重",
        "听一句劝，这事真的别碰","不太行哦，换个思路吧","别执着加入进去了，这不是正确的选择",
        "此方案驳回，重新规划","别犟了，行不通就是行不通"
      ];

      let answers = builtin.slice();

      // pick random and animate show
      function randPick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
      function animateShow(text){
        answerEl.classList.add('hidden');
        setTimeout(()=>{
          answerEl.textContent = text;
          answerEl.classList.remove('hidden');
          answerEl.classList.add('pop');
          setTimeout(()=> answerEl.classList.remove('pop'), 420);
        }, 140);
      }
      function showRandom(){ if (answers.length) animateShow(randPick(answers)); }

      // try load external answers.json to override
      fetch('./answers.json', {cache: "no-store"}).then(r=>{
        if (!r.ok) throw new Error('no json');
        return r.json();
      }).then(json=>{
        if (Array.isArray(json) && json.length>0) answers = json.map(String);
      }).catch(()=>{}).finally(()=> showRandom());

      // controls
      newBtn.addEventListener('click', showRandom);
      document.addEventListener('keydown', e=>{
        if (document.activeElement && (document.activeElement.tagName==='INPUT' || document.activeElement.tagName==='TEXTAREA')) return;
        if (e.code === 'Space' || e.key === ' '){ e.preventDefault(); showRandom(); }
      });

      copyBtn.addEventListener('click', async ()=>{
        try{ await navigator.clipboard.writeText(answerEl.textContent || ''); copyBtn.textContent='已复制'; setTimeout(()=>copyBtn.textContent='复制',1200); }
        catch(e){ copyBtn.textContent='复制失败'; setTimeout(()=>copyBtn.textContent='复制',1200); }
      });

      // Expose for debugging
      window.AnswerBook = { showRandom, answers };

    })();
  </script>
</body>
</html>
